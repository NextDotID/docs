"use strict";(self.webpackChunknext_id_doc=self.webpackChunknext_id_doc||[]).push([[6844],{3409:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"developer-guide/rust","title":"Rust","description":"Proof Service","source":"@site/docs/developer-guide/rust.md","sourceDirName":"developer-guide","slug":"/developer-guide/rust","permalink":"/developer-guide/rust","draft":false,"unlisted":false,"editUrl":"https://github.com/nextdotid/docs/edit/main/docs/developer-guide/rust.md","tags":[],"version":"current","frontMatter":{"title":"Rust"}}');var r=t(5105),a=t(3881);const i={title:"Rust"},o=void 0,c={},d=[{value:"Proof Service",id:"proof-service",level:2}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"proof-service",children:"Proof Service"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["You can git clone and run ",(0,r.jsx)(n.a,{href:"https://github.com/nextdotid/Signature-Generating-Sample/tree/main/rust",children:"Rust open demo"})," for help."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The core example of codes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-toml",metastring:'title="Cargo.toml"',children:'[dependencies]\nlibsecp256k1 = "0.7"\nhex = "0.4"\nsha3 = "0.10" # Keccak256\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="src/main.rs"',children:'use libsecp256k1::{SecretKey, Message};\nuse sha3::{Keccak256, Digest};\n\nconst SECRET_KEY: &str = "9DEBA3488458C0314E5FEF8920D3B117DD76415569CF270DB8FD864896C02732";\nconst SIGN_PAYLOAD: &str = "Test123123!";\n\nfn main() {\n    // Raw sign message\n    let sign_payload: String = SIGN_PAYLOAD.to_string();\n    // SecretKey instance\n    let secret_key = SecretKey::parse_slice(hex::decode(SECRET_KEY).unwrap().as_slice()).unwrap();\n    // Sign it\n    let personal_signature = personal_sign(&sign_payload, &secret_key);\n    // Verify it\n    println!("Signature: 0x{}", hex::encode(personal_signature));\n    // Signature: 0x52f210dadad13c4c8d0656e7380300a367a056631cf26950baa7de4f580187795c76b5fc94de5bd0b8af4d5df432687d900402cba86a12570af56be35ba8d56401\n}\n\n/// `web3.eth.personal.sign()`\nfn personal_sign(payload: &String, secret_key: &SecretKey) -> Vec<u8> {\n    // Wrap personal.sign() required signature struct\n    let personal_message = format!("\\x19Ethereum Signed Message:\\n{}{}", payload.len(), payload);\n    // Keccak256 it into a digest.\n    let mut hasher = Keccak256::default();\n    hasher.update(personal_message);\n    let digest: [u8; 32] = hasher.finalize().into();\n\n    // Sign the digest.\n    let (r_and_s, v) = libsecp256k1::sign(&Message::parse(&digest), secret_key);\n    // Rebuild the sig into a [u8; 65]\n    let mut signature: Vec<u8> = vec![];\n    signature.extend_from_slice(&r_and_s.r.b32()); // r (32 bytes)\n    signature.extend_from_slice(&r_and_s.s.b32()); // s (32 bytes)\n    signature.push(v.serialize()); // v (1 byte)\n    if signature.len() != 65 {\n        panic!("Signature length is not 65 bytes");\n    }\n    signature\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},3881:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(8101);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);